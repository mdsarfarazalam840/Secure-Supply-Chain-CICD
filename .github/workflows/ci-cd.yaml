name: Secure Supply Chain CI/CD

on:
  push:
    branches: ["main", "clouds"]
  pull_request:
    branches: ["main"]

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER: secure-supply-chain-cluster
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/secure-supply-chain-app

permissions:
  id-token: write
  contents: read

jobs:
  terraform-infra:
    name: Provision/Update AWS Infra and EKS Cluster
    runs-on: ubuntu-latest
    outputs:
      cluster_endpoint: ${{ steps.terraform_lifecycle.outputs.cluster_endpoint }}
      cluster_ca_certificate: ${{ steps.terraform_lifecycle.outputs.cluster_ca_certificate }}
      cluster_name: ${{ steps.terraform_lifecycle.outputs.cluster_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Run Terraform Lifecycle
        id: terraform_lifecycle
        env:
          AWS_REGION: ${{ vars.AWS_REGION }}
          PROJECT_NAME: secure-supply-chain
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          ./scripts/terraform-lifecycle.sh


  build-scan-sign:
    name: Build, Scan, and Sign Docker Image
    runs-on: ubuntu-latest
    needs: terraform-infra
    outputs:
      image_uri: ${{ steps.push.outputs.digest }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Load environment variables
        run: |
          if [ -f .env ]; then
            grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' >> $GITHUB_ENV
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions
          aws-region: ${{ env.AWS_REGION }}

      - name: Test AWS access
        run: |
          aws sts get-caller-identity
          echo "Successfully assumed role!"

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build, tag, and push image to Docker Hub
        id: push
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG ./app
          docker build -t ${{ env.DOCKER_IMAGE }}:latest ./app
          docker push ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG
          docker push ${{ env.DOCKER_IMAGE }}:latest
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG | cut -d'@' -f2)
          echo "digest=${{ env.DOCKER_IMAGE }}@${DIGEST}" >> $GITHUB_OUTPUT

      - name: Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'

      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh
          mkdir -p $HOME/.local/bin
          mv ./bin/syft $HOME/.local/bin/
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Generate SBOM
        run: |
          syft ${{ env.DOCKER_IMAGE }}:${{ github.sha }} -o json > sbom.json
          echo "SBOM generated successfully"

      - name: Install Cosign
        run: |
          curl -sSfL https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64 -o cosign
          chmod +x cosign
          mv cosign $HOME/.local/bin/cosign
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Generate Cosign Key Pair
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          COSIGN_PASSWORD="" cosign generate-key-pair
          echo 'COSIGN_PRIVATE_KEY<> $GITHUB_ENV
          echo 'COSIGN_PUBLIC_KEY<> $GITHUB_ENV

      - name: Sign Docker Image
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "${{ env.COSIGN_PRIVATE_KEY }}" > cosign.key
          chmod 600 cosign.key
          COSIGN_PASSWORD="" cosign sign --yes --key cosign.key ${{ steps.push.outputs.digest }}
          rm cosign.key

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.json

      - name: Upload Cosign Public Key
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: cosign-public-key
          path: cosign.pub

  security-scan:
    name: Security Scan After Build
    runs-on: ubuntu-latest
    needs: build-scan-sign
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Download SBOM
        uses: actions/download-artifact@v4
        with:
          name: sbom

      - name: Run Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'Secure Supply Chain'
          path: '.'
          format: 'HTML'
          out: 'reports'

      - name: Upload Security Report
        uses: actions/upload-artifact@v4
        with:
          name: security-report
          path: reports/

  deploy:
    name: Deploy Kubernetes Resources and App
    runs-on: ubuntu-latest
    needs: [terraform-infra, build-scan-sign, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/clouds'
    env:
      EKS_CLUSTER: ${{ needs.terraform-infra.outputs.cluster_name }}
      AWS_REGION: ${{ vars.AWS_REGION }}
      IMAGE_TAG: ${{ github.sha }}
      IMAGE_URI: ${{ secrets.DOCKER_USERNAME }}/secure-supply-chain-app:${{ github.sha }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}

      - name: Download Cosign Public Key
        uses: actions/download-artifact@v4
        with:
          name: cosign-public-key

      - name: Update Kyverno Policy with Public Key
        run: |
          if [ -f "cosign.pub" ]; then
            PUBLIC_KEY=$(cat cosign.pub)
            sed -i "s|# This will be replaced with the actual public key from Cosign|$PUBLIC_KEY|g" k8s/policy.yaml
            echo "Updated Kyverno policy with Cosign public key"
          else
            echo "Cosign public key not found, using default policy"
          fi

      - name: Deploy to EKS
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          if [ -f .env ]; then
            export $(grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' | xargs)
          fi
          export IMAGE_URI=${{ env.DOCKER_IMAGE }}:${IMAGE_TAG}
          export APP_NAME=${APP_NAME:-secure-app}
          export SERVICE_NAME=${SERVICE_NAME:-secure-app-service}
          export DEPLOYMENT_NAME=${DEPLOYMENT_NAME:-secure-app-deployment}
          export NODE_ENV=${NODE_ENV:-production}
          export NAMESPACE=${NAMESPACE:-default}
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          if [ -f "k8s/policy.yaml" ]; then
            envsubst < k8s/policy.yaml | kubectl apply -f -
          fi
          envsubst < k8s/deployment.yaml | kubectl apply -f -
          envsubst < k8s/service.yaml | kubectl apply -f -
          envsubst < k8s/ingress.yaml | kubectl apply -f -
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=300s
          kubectl get pods -n $NAMESPACE -l app=$APP_NAME
          kubectl get service -n $NAMESPACE $SERVICE_NAME

      - name: Get Load Balancer URL
        run: |
          echo "Waiting for Load Balancer to be provisioned..."
          kubectl get service secure-app-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' > lb_url.txt
          echo "Load Balancer URL: $(cat lb_url.txt)"

      - name: Upload Load Balancer URL
        uses: actions/upload-artifact@v4
        with:
          name: loadbalancer-url
          path: lb_url.txt