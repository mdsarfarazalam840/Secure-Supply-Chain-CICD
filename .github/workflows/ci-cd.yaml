name: Secure Supply Chain CI/CD

on:
  push:
    branches: [ "main", "clouds" ]
  pull_request:
    branches: [ "main" ]

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER: secure-supply-chain-cluster
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/secure-supply-chain-app

permissions:
  id-token: write
  contents: read

jobs:
  # Stage 1: Terraform Infrastructure
  terraform-infra:
    name: Provision/Update EKS Infrastructure
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -input=false -var="aws_region=us-east-1"

      - name: Terraform Apply
        if: github.event_name == 'push' && github.ref == 'refs/heads/clouds'
        working-directory: ./terraform
        run: terraform apply -auto-approve -input=false -var="aws_region=us-east-1"

      - name: Get Terraform Outputs
        id: tfoutputs
        working-directory: ./terraform
        run: |
          echo "CLUSTER_NAME=$(terraform output -raw cluster_name)" >> $GITHUB_ENV
          echo "AWS_REGION=$(terraform output -raw aws_region)" >> $GITHUB_ENV
          echo "EKS_CLUSTER=$(terraform output -raw cluster_name)" >> $GITHUB_ENV
          echo "ROLE_ARN=$(terraform output -raw github_actions_role_arn)" >> $GITHUB_ENV
          echo "VPC_ID=$(terraform output -raw vpc_id)" >> $GITHUB_ENV
          echo "PRIVATE_SUBNETS=$(terraform output -raw private_subnets)" >> $GITHUB_ENV
          echo "PUBLIC_SUBNETS=$(terraform output -raw public_subnets)" >> $GITHUB_ENV
          echo "CONFIGURE_KUBECTL=$(terraform output -raw configure_kubectl)" >> $GITHUB_ENV
          echo "GITHUB_REPO=$(terraform output -raw github_repository)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_ARN=$(terraform output -raw github_actions_role_arn)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_NAME=$(terraform output -raw github_actions_role_name)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_POLICY_ARN=$(terraform output -raw github_actions_role_policy_arn)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_POLICY_NAME=$(terraform output -raw github_actions_role_policy_name)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_POLICY_ARN=$(terraform output -raw github_actions_role_policy_arn)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_POLICY_NAME=$(terraform output -raw github_actions_role_policy_name)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_POLICY_ARN=$(terraform output -raw github_actions_role_policy_arn)" >> $GITHUB_ENV
          echo "GITHUB_ACTIONS_ROLE_POLICY_NAME=$(terraform output -raw github_actions_role_policy_name)" >> $GITHUB_ENV


  # Stage 2: Build, Scan, and Sign (runs first)
  build-scan-sign:
    runs-on: ubuntu-latest
    needs: terraform-infra
    outputs:
      image_uri: ${{ steps.push.outputs.digest }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Load environment variables
        run: |
          if [ -f .env ]; then
            grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' >> $GITHUB_ENV
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions
          aws-region: ${{ env.AWS_REGION }}

      - name: Test AWS access
        run: |
          aws sts get-caller-identity
          echo "Successfully assumed role!"

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build, tag, and push image to Docker Hub
        id: push
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG ./app
          docker build -t ${{ env.DOCKER_IMAGE }}:latest ./app
          docker push ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG
          docker push ${{ env.DOCKER_IMAGE }}:latest
          # Fixed: Get proper digest
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG | cut -d'@' -f2)
          echo "digest=${{ env.DOCKER_IMAGE }}@${DIGEST}" >> $GITHUB_OUTPUT

      - name: Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'

      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh
          mkdir -p $HOME/.local/bin
          mv ./bin/syft $HOME/.local/bin/
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Generate SBOM
        run: |
          syft ${{ env.DOCKER_IMAGE }}:${{ github.sha }} -o json > sbom.json
          echo "SBOM generated successfully"

      - name: Install Cosign
        run: |
          curl -sSfL https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64 -o cosign
          chmod +x cosign
          mv cosign $HOME/.local/bin/cosign
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      # Fixed: Proper heredoc syntax
      - name: Generate Cosign Key Pair
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          COSIGN_PASSWORD="" cosign generate-key-pair
          {
            echo 'COSIGN_PRIVATE_KEY<<EOF'
            cat cosign.key
            echo 'EOF'
          } >> $GITHUB_ENV
          {
            echo 'COSIGN_PUBLIC_KEY<<EOF'
            cat cosign.pub
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: Sign Docker Image
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "${{ env.COSIGN_PRIVATE_KEY }}" > cosign.key
          chmod 600 cosign.key
          COSIGN_PASSWORD="" cosign sign --yes --key cosign.key ${{ steps.push.outputs.digest }}
          rm cosign.key

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.json

      - name: Upload Cosign Public Key
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: cosign-public-key
          path: cosign.pub

  # Stage 3: Security Scan (runs after build, before deploy)
  security-scan:
    runs-on: ubuntu-latest
    needs: build-scan-sign
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Download SBOM
        uses: actions/download-artifact@v4
        with:
          name: sbom

      - name: Run Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'Secure Supply Chain'
          path: '.'
          format: 'HTML'
          out: 'reports'

      - name: Upload Security Report
        uses: actions/upload-artifact@v4
        with:
          name: security-report
          path: reports/

  # Stage 4: Deploy (runs last, only after security scan passes)
  deploy:
    runs-on: ubuntu-latest
    needs: [terraform-infra, build-scan-sign, security-scan]  # Changed: Now waits for both jobs
    if: github.event_name == 'push' && github.ref == 'refs/heads/clouds'
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Load environment variables
        run: |
          if [ -f .env ]; then
            grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' >> $GITHUB_ENV
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}

      - name: Download Cosign Public Key
        uses: actions/download-artifact@v4
        with:
          name: cosign-public-key

      - name: Update Kyverno Policy with Public Key
        run: |
          if [ -f "cosign.pub" ]; then
            PUBLIC_KEY=$(cat cosign.pub)
            sed -i "s|# This will be replaced with the actual public key from Cosign|$PUBLIC_KEY|g" k8s/policy.yaml
            echo "Updated Kyverno policy with Cosign public key"
          else
            echo "Cosign public key not found, using default policy"
          fi

      - name: Deploy to EKS
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Load environment variables from .env file
          if [ -f .env ]; then
            export $(grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' | xargs)
          fi

          # Set deployment variables
          export IMAGE_URI=${{ env.DOCKER_IMAGE }}:${IMAGE_TAG}
          export APP_NAME=${APP_NAME:-secure-app}
          export SERVICE_NAME=${SERVICE_NAME:-secure-app-service}
          export DEPLOYMENT_NAME=${DEPLOYMENT_NAME:-secure-app-deployment}
          export NODE_ENV=${NODE_ENV:-production}
          export NAMESPACE=${NAMESPACE:-default}

          echo "Deploying with configuration:"
          echo "Image: $IMAGE_URI"
          echo "App: $APP_NAME"
          echo "Service: $SERVICE_NAME"
          echo "Deployment: $DEPLOYMENT_NAME"
          echo "Environment: $NODE_ENV"
          echo "Namespace: $NAMESPACE"

          # Create namespace if it doesn't exist
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

          # Apply Kyverno policy for image verification
          if [ -f "k8s/policy.yaml" ]; then
            envsubst < k8s/policy.yaml | kubectl apply -f -
          fi

          # Deploy application with environment variable substitution
          envsubst < k8s/deployment.yaml | kubectl apply -f -
          envsubst < k8s/service.yaml | kubectl apply -f -
          envsubst < k8s/ingress.yaml | kubectl apply -f -

          # Wait for deployment to be ready
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=300s

          # Show deployment status
          kubectl get pods -n $NAMESPACE -l app=$APP_NAME
          kubectl get service -n $NAMESPACE $SERVICE_NAME

      - name: Get Load Balancer URL
        run: |
          echo "Waiting for Load Balancer to be provisioned..."
          kubectl get service secure-app-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' > lb_url.txt
          echo "Load Balancer URL: $(cat lb_url.txt)"

      - name: Upload Load Balancer URL
        uses: actions/upload-artifact@v4
        with:
          name: loadbalancer-url
          path: lb_url.txt
