name: Secure Supply Chain CI/CD

on:
  push:
    branches: [ "main", "clouds" ]  
  pull_request:
    branches: [ "main" ]

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER: secure-supply-chain-cluster
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/secure-supply-chain-app

permissions:
  id-token: write
  contents: read

jobs:
  build-scan-sign:
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.push.outputs.digest }}
    
    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    # Add this step to load .env variables
    - name: Load environment variables
      run: |
        if [ -f .env ]; then
          # Load non-sensitive variables to GITHUB_ENV
          grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' >> $GITHUB_ENV
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build, tag, and push image to Docker Hub
      id: push
      env:
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG ./app
        docker build -t ${{ env.DOCKER_IMAGE }}:latest ./app
        docker push ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG
        docker push ${{ env.DOCKER_IMAGE }}:latest
        echo "digest=${{ env.DOCKER_IMAGE }}@$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.DOCKER_IMAGE }}:$IMAGE_TAG | cut -d'@' -f2)" >> $GITHUB_OUTPUT

    - name: Scan with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
        format: 'table'
        exit-code: '0'
        severity: 'CRITICAL,HIGH'

    - name: Install Syft
      run: |
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh
        mkdir -p $HOME/.local/bin
        mv ./bin/syft $HOME/.local/bin/
        echo "$HOME/.local/bin" >> $GITHUB_PATH

    - name: Generate SBOM
      run: |
        syft ${{ env.DOCKER_IMAGE }}:${{ github.sha }} -o json > sbom.json
        echo "SBOM generated successfully"

    - name: Install Cosign
      run: |
        curl -sSfL https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64 -o cosign
        chmod +x cosign
        mv cosign $HOME/.local/bin/cosign
        echo "$HOME/.local/bin" >> $GITHUB_PATH

    - name: Generate Cosign Key Pair
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        cosign generate-key-pair
        echo "COSIGN_PRIVATE_KEY<<EOF" >> $GITHUB_ENV  # Fixed heredoc syntax
        cat cosign.key >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        echo "COSIGN_PUBLIC_KEY<<EOF" >> $GITHUB_ENV   # Fixed heredoc syntax
        cat cosign.pub >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: Sign Docker Image
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        echo "${{ env.COSIGN_PRIVATE_KEY }}" > cosign.key
        chmod 600 cosign.key
        cosign sign --yes --key cosign.key ${{ steps.push.outputs.digest }}
        rm cosign.key

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.json

    - name: Upload Cosign Public Key
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: actions/upload-artifact@v4
      with:
        name: cosign-public-key
        path: cosign.pub

  deploy:
    runs-on: ubuntu-latest
    needs: build-scan-sign
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Load environment variables
      run: |
        if [ -f .env ]; then
          grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' >> $GITHUB_ENV
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}

    - name: Download Cosign Public Key
      uses: actions/download-artifact@v4
      with:
        name: cosign-public-key

    - name: Update Kyverno Policy with Public Key
      run: |
        if [ -f "cosign.pub" ]; then
          PUBLIC_KEY=$(cat cosign.pub)
          sed -i "s|# This will be replaced with the actual public key from Cosign|$PUBLIC_KEY|g" k8s/policy.yaml
          echo "Updated Kyverno policy with Cosign public key"
        else
          echo "Cosign public key not found, using default policy"
        fi

    - name: Deploy to EKS
      env:
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Load environment variables from .env file
        if [ -f .env ]; then
          export $(grep -v 'PASSWORD\|SECRET\|KEY\|TOKEN' .env | grep -v '^#' | grep -v '^$' | xargs)
        fi
        
        # Set deployment variables
        export IMAGE_URI=${{ env.DOCKER_IMAGE }}:${IMAGE_TAG}
        export APP_NAME=${APP_NAME:-secure-app}
        export SERVICE_NAME=${SERVICE_NAME:-secure-app-service}
        export DEPLOYMENT_NAME=${DEPLOYMENT_NAME:-secure-app-deployment}
        export NODE_ENV=${NODE_ENV:-production}
        export NAMESPACE=${NAMESPACE:-default}
        
        echo "Deploying with configuration:"
        echo "Image: $IMAGE_URI"
        echo "App: $APP_NAME"
        echo "Service: $SERVICE_NAME"
        echo "Deployment: $DEPLOYMENT_NAME"
        echo "Environment: $NODE_ENV"
        echo "Namespace: $NAMESPACE"
        
        # Create namespace if it doesn't exist
        kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply Kyverno policy for image verification
        if [ -f "k8s/policy.yaml" ]; then
            envsubst < k8s/policy.yaml | kubectl apply -f -
        fi
        
        # Deploy application with environment variable substitution
        envsubst < k8s/deployment.yaml | kubectl apply -f -
        envsubst < k8s/service.yaml | kubectl apply -f -
        envsubst < k8s/ingress.yaml | kubectl apply -f -
        
        # Wait for deployment to be ready
        kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=300s
        
        # Show deployment status
        kubectl get pods -n $NAMESPACE -l app=$APP_NAME
        kubectl get service -n $NAMESPACE $SERVICE_NAME
  

    - name: Get Load Balancer URL
      run: |
        echo "Waiting for Load Balancer to be provisioned..."
        kubectl get service secure-app-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' > lb_url.txt
        echo "Load Balancer URL: $(cat lb_url.txt)"

    - name: Upload Load Balancer URL
      uses: actions/upload-artifact@v4
      with:
        name: loadbalancer-url
        path: lb_url.txt

  security-scan:
    runs-on: ubuntu-latest
    needs: build-scan-sign
    
    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Download SBOM
      uses: actions/download-artifact@v4
      with:
        name: sbom

    - name: Run Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'Secure Supply Chain'
        path: '.'
        format: 'HTML'
        out: 'reports'

    - name: Upload Security Report
      uses: actions/upload-artifact@v4
      with:
        name: security-report
        path: reports/
